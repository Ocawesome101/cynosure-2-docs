                        ** SFS: The Simple File System **

    SFS is an extremely simple filesystem.  It is not intended to be fast or efficient - only to be simple to implement.

    All numbers are little-endian.

    The first sector of a SFS-formatted disk contains the superblock.  This contains a lilttle bit of data about the filesystem.

      struct Superblock {
        char flags;
        uint16_t namelist_blocks;
        uint16_t blocksize;
        uint16_t blocks;
        uint16_t blocks_used;
      }

    The following file system flags should have an effect:
      0x1 - File system was not cleanly unmounted, so run a filesystem check
      0x2 - File system is read-only

    SFS represents all its file data in a Namelist, which immediately follows the superblock.  It is a preallocated space Superblock.namelist_size blocks long and contains entries in the following format:

      struct Namelist_entry {
        uint16_t flags;
        uint16_t datablock;
        uint16_t next_entry;
        uint16_t size;
        uint64_t created;
        uint64_t modified;
        char fname[40];
      }

    Namelist entry flags are exactly the same as the standard POSIX file flags.

    The datablock pointer points to the block at which the file data begins.  If the entry is a directory, this is actually a pointer to the first file in the directory.  If the entry is a symbolic link, this data block stores the path to which the link points.  If the entry is a character or block device, this stores its major and minor device numbers.

    The size field stores size relative to the last allocated block.

    Directory listings are singly linked lists.  The next_entry field marks the next file entry in the Namelist in that listing of directories.  A value of zero indicates the end of the directory listing.

    Since the Namelist_entry structure is 64 bytes long, finding a file at an index in the Namelist is simple: multiply its index by 64 and read the 64 bytes at that offset.

    This is a fairly slow implementation of a file tree, and driver authors will probably want to cache as much of this tree as possible for speed reasons.

    When the Namelist is full, no more files can be allocated.

    A 4KB Namelist holds 64 files.  A 64KB Namelist holds 1024 files.

    Each file datablock holds (Superblock.blocksize - 2) bytes of data followed by a pointer to the next block.  If this pointer has a value of zero, that is the end of the file data.


    Immediately following the Namelist is the Blockmap.  This is an array of bits specifying what blocks have been used and what blocks are not used.


    The following are some suggested disk layouts for certain disk sizes:
      512 KB total (OpenComputers floppy disk):
        1 KB blocks
        64 KB Namelist (1024 files)
        64-byte Blockmap
        Total overhead 64*1025=65600 bytes
  
      1 MB total (OpenComputers T1 hard disk):
        1 KB blocks
        128 KB Namelist (2048 files)
        128-byte Blockmap
        Total overhead 128*1025=131200 bytes
  
      2 MB total (OpenComputers T2 hard disk):
        1 KB blocks
        128 KB Namelist (2048 files)
        256-byte Blockmap
        Total overhead 128*1026=131328 bytes
  
      4 MB total (OpenComputers T3 hard disk):
        1 KB blocks
        192 KB Namelist (3072 files)
        512-byte Blockmap
        Total overhead 192*1024+512=197120 bytes
  
      16 MB total:
        1 KB blocks
        512 KB Namelist (8192 files)
        2 KB Blockmap
        Total overhead 514*1024=526336 bytes
  
      64 MB total (maximum size with 1KB blocks):
        1 KB blocks
        1 MB Namelist (16384 files)
        8 KB Blockmap
        Total overhead 1MB+8KB
  
      128 MB total (maximum size with 2KB blocks):
        2 KB blocks
        2 MB Namelist (32768 files)
        16 KB Blockmap
        Total overhead 2MB+16KB
    
      4 GB total (maximum size)
        64 KB blocks
        16 MB Namelist (262144 files)
        8 KB Blockmap
        Total overhead 16MB+8KB
